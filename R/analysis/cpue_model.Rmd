---
title: "Cod density in relation to environmental variables"
author: "Max Lindmark, Sean Andersson, Michele Casini"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
  df_print: paged
pdf_document: default
editor_options: 
  chunk_output_type: console
---
  
```{r setup, include = FALSE, cache=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 12,
  fig.asp = 0.618,
  fig.align ='center'
)
```

# Intro
Fit density (also referred to as CPUE) model with environmental predictors and use that to calculate weighted mean dissolved oxygen, temperature and depth of Baltic cod

```{r lib, message=FALSE}
# Load libraries, install if needed
library(tidyverse); theme_set(theme_light(base_size = 11))
library(readxl)
library(tidylog)
library(RCurl)
library(viridis)
library(RColorBrewer)
library(patchwork)
library(janitor)
library(icesDatras)
library(mapdata)
library(patchwork)
library(rgdal)
library(raster)
library(sf)
library(rgeos)
library(chron)
library(lattice)
library(ncdf4)
library(marmap)
library(rnaturalearth)
library(rnaturalearthdata)
library(mapplots)
library(qwraps2) 
library(wesanderson)
#remotes::install_github("pbs-assess/sdmTMB")
library(sdmTMB)

# To load entire cache in interactive r session, do: 
# qwraps2::lazyload_cache_dir(path = "R/analysis/cpue_model_cache/html")
```

## For maps

```{r read coastline data, message=FALSE, warning=FALSE}
# Specify map ranges
ymin = 52; ymax = 60; xmin = 10; xmax = 24

map_data <- rnaturalearth::ne_countries(
  scale = "medium",
  returnclass = "sf", continent = "europe")

# Crop the polygon for plotting and efficiency:
# st_bbox(map_data) # find the rough coordinates
swe_coast <- suppressWarnings(suppressMessages(
  st_crop(map_data,
          c(xmin = xmin, ymin = ymin, xmax = xmax, ymax = ymax))))

# Transform our map into UTM 33 coordinates, which is the equal-area projection we fit in:
utm_zone33 <- 32633
swe_coast_proj <- sf::st_transform(swe_coast, crs = utm_zone33)

# Define plotting theme for main plot
theme_plot <- function(base_size = 10, base_family = "") {
  theme_light(base_size = 10, base_family = "") +
    theme(
      axis.text.x = element_text(angle = 90),
      axis.text = element_text(size = 8),
      legend.text = element_text(size = 8),
      legend.title = element_text(size = 8),
      legend.position = "bottom",
      legend.key.height = unit(0.2, "cm"),
      legend.margin = margin(0, 0, 0, 0),
      legend.box.margin = margin(-5, -5, -5, -5),
      strip.text = element_text(size = 8, colour = 'gray10', margin = margin()),
      strip.background = element_rect(fill = "grey95")
      )
}

# Define plotting theme for facet_wrap map with years
theme_facet_map <- function(base_size = 10, base_family = "") {
  theme_light(base_size = 10, base_family = "") +
    theme(
        axis.text.x = element_text(angle = 90),
        axis.text = element_text(size = 6),
        strip.text = element_text(size = 8, colour = 'gray10', margin = margin()),
        strip.background = element_rect(fill = "gray95"),
        legend.position = c(0.7, 0.02),
        legend.direction = "horizontal"
      )
}

# Make default base map plot
xmin2 <- 303000; xmax2 <- 916000; xrange <- xmax2 - xmin2
ymin2 <- 5980000; ymax2 <- 6450000; yrange <- ymax2 - ymin2

plot_map_raster <- 
ggplot(swe_coast_proj) + 
  xlim(xmin2, xmax2) +
  ylim(ymin2, ymax2) +
  labs(x = "Longitude", y = "Latitude") +
  geom_sf(size = 0.3) + 
  theme_plot()

plot_map_raster_labels <- 
  plot_map_raster + 
  annotate("text", label = "Sweden", x = xmin2 + 0.25*xrange, y = ymin2 + 0.8*yrange, color = "black", size = 1.9) +
  annotate("text", label = "Denmark", x = xmin2 + 0.029*xrange, y = ymin2 + 0.43*yrange, color = "black", size = 1.9, angle = 75) +
  annotate("text", label = "Germany", x = xmin2 + 0.07*xrange, y = ymin2 + 0.025*yrange, color = "black", size = 1.9) +
  annotate("text", label = "Poland", x = xmin2 + 0.55*xrange, y = ymin2 + 0.1*yrange, color = "black", size = 1.9) +
  annotate("text", label = "Russia", x = xmin2 + 0.95*xrange, y = ymin2 + 0.2*yrange, color = "black", size = 1.9) +
  annotate("text", label = "Lithuania", x = xmin2 + 1*xrange, y = ymin2 + 0.47*yrange, color = "black", size = 1.9, angle = 75) +
  annotate("text", label = "Latvia", x = xmin2 + 0.99*xrange, y = ymin2 + 0.68*yrange, color = "black", size = 1.9, angle = 75)
```

## Read data

```{r read and process data, message=FALSE, warning=FALSE}
d <- readr::read_csv("https://raw.githubusercontent.com/maxlindmark/cod_condition/master/data/for_analysis/mdat_cpue_q_1_4.csv")

# Calculate standardized variables
d <- d %>% 
  filter(year < 2020 & year > 1992 & quarter == 4) %>% 
  mutate(oxy_sc = oxy,
         temp_sc = temp,
         depth_sc = depth,
         ) %>%
  mutate_at(c("oxy_sc", "temp_sc", "depth_sc"),
            ~(scale(.) %>% as.vector)) %>% 
  mutate(year = as.integer(year)) %>% 
  drop_na(oxy, depth, temp)

plot_map_raster +
  geom_point(data = d, aes(X*1000, Y*1000))
```

## Read the prediction grids

```{r read and process prediction grid, message=FALSE, warning=FALSE}
pred_grid1 <- readr::read_csv("https://raw.githubusercontent.com/maxlindmark/cod_condition/master/data/for_analysis/pred_grid_(1_2).csv")
pred_grid <- readr::read_csv("https://raw.githubusercontent.com/maxlindmark/cod_condition/master/data/for_analysis/pred_grid_(2_2).csv")

pred_grid <- bind_rows(pred_grid1, pred_grid)

# Standardize data with respect to prediction grid:
pred_grid <- pred_grid %>%
  mutate(year = as.integer(year)) %>% 
  filter(year %in% c(unique(d$year))) %>% 
  mutate(depth_sc = (depth - mean(d$depth))/sd(d$depth),
         temp_sc = (temp - mean(d$temp))/sd(d$temp),
         oxy_sc = (oxy - mean(d$oxy))/sd(d$oxy)) %>% # Need to scale these to the mean and sd in the data!
  drop_na(oxy, depth, temp)
```

## Make spde mesh

```{r make barrier spde mesh, results='hide', cache=TRUE, message=FALSE}
spde <- make_mesh(d, xy_cols = c("X", "Y"),
                  n_knots = 200, 
                  type = "kmeans", seed = 42)

# Plot and save spde
png(file = "figures/supp/density/spde.png", units = "in", width = 6.5, height = 6.5, res = 300)
plot(spde)
dev.off()
```

## Fit the density model

```{r fit, results='hide', cache=TRUE, message=FALSE}
# Depth spline + oxy spline
# Takes about 30 minutes
m <- sdmTMB(density ~ 0 + as.factor(year) + s(depth_sc) + s(oxy_sc) + s(temp_sc),
            data = d, mesh = spde, family = tweedie(link = "log"),
            spatiotemporal = "AR1", spatial = "on", time = "year",
            reml = FALSE, control = sdmTMBcontrol(newton_steps = 1))

tidy(m, conf.int = TRUE)
```

## Check QQ plot and residuals

```{r qqplot and resid, results='hide', cache=TRUE, message=FALSE}
d$residualsm <- residuals(m)

png(file = "figures/supp/density/qq.png", units = "in", width = 6.5, height = 6.5, res = 300)
qqnorm(d$residualsm); abline(a = 0, b = 1)
dev.off()

# Residuals on map
plot_map_raster +
  geom_point(data = d, aes(x = X * 1000, y = Y * 1000, color = residualsm)) +
  scale_colour_gradient2() +
  facet_wrap(~ year, ncol = 5) +
  labs(color = "residuals") +
  theme(strip.text = element_text(size = 8, colour = 'black', margin = margin()),
        strip.background = element_rect(fill = "grey90"))

ggsave("figures/supp/density/spatial_resid.png", width = 6.5, height = 6.5, dpi = 600)
```

## Check the AR1 parameter (`rho` is `ar_phi` on the -1 to 1 scale):

```{r check AR1 estimate}
tidy(m, effects = "ran_pars", conf.int = TRUE) %>% filter(term == "rho")
```

## Predict on grid

```{r predict, cache=TRUE}
predict_mcod <- predict(m, newdata = pred_grid)

# Save prediction as csv (smaller than the model object...)
write.csv(predict_mcod, "output/predict_mcod_density.csv")
```

## Plot predictions on map

```{r plot}
# Plot predicted density and random effects
plot_map_raster +
  geom_raster(data = predict_mcod, aes(x = X * 1000, y = Y * 1000, fill = exp(est))) +
  scale_fill_viridis_c(trans = "sqrt") +
  facet_wrap(~ year, ncol = 5) +
  labs(fill = expression(kg/km^2)) +
  ggtitle("Predicted density (fixed + random)")
  
ggsave("figures/supp/density/est_map.png", width = 6.5, height = 6.5, dpi = 600)

# Plot spatiotemporal random effect
plot_map_raster +
  geom_raster(data = predict_mcod, aes(x = X * 1000, y = Y * 1000, fill = epsilon_st)) +
  scale_fill_gradient2() +
  facet_wrap(~ year, ncol = 5) +
  ggtitle("Spatiotemporal random effects")

ggsave("figures/supp/density/epsilon_st_map.png", width = 6.5, height = 6.5, dpi = 600)

# Plot spatial random effect
plot_map_raster +
  geom_raster(data = filter(predict_mcod, year == 1999), aes(x = X * 1000, y = Y * 1000, fill = omega_s)) +
  scale_fill_gradient2() +
  facet_wrap(~ year, ncol = 5) +
  theme_plot() +
  ggtitle("Spatial random effects")
  
ggsave("figures/supp/density/omega_s_map.png", width = 6.5, height = 6.5, dpi = 600)
```

## Get the annual index

```{r cpue index, message=FALSE, cache=TRUE}
# # From these models, predict annual cpue index
# # Make a new prediction this time without the deep areas! For the previous plot, I predict first then make NA 
# # to make them more visible on the map. Here I don't want them to be included in the index-calculation
# 
# # First, get an index for average density (which we can compare with data)
# ncells <- filter(pred_grid, year == max(pred_grid$year)) %>% nrow()
# 
# # Total prediction 
# preds_cod_ave <- predict(m, newdata = pred_grid, return_tmb_object = TRUE, area = 1/ncells)
# 
# # Now get the total index by specifying the area of a grid cell
# # Total prediction 
# preds_cod <- predict(m, newdata = pred_grid, return_tmb_object = TRUE, area = 2*2)
# 
# # Total prediction (omitting SD 24!)
# preds_cod25_28 <- predict(m, newdata = filter(pred_grid, !sub_div == 24),
#                           return_tmb_object = TRUE, area = 2*2)
# 
# # SD 24-25
# preds_cod24_25 <- predict(m, newdata = filter(pred_grid, sub_div %in% c(24, 25)),
#                           return_tmb_object = TRUE, area = 2*2)
# 
# # SD 24
# preds_cod24 <- predict(m, newdata = filter(pred_grid, sub_div == 24),
#                        return_tmb_object = TRUE, area = 2*2)
# 
# # SD 25
# preds_cod25 <- predict(m, newdata = filter(pred_grid, sub_div == 25),
#                        return_tmb_object = TRUE, area = 2*2)
# 
# # SD 26
# preds_cod26 <- predict(m, newdata = filter(pred_grid, sub_div == 26),
#                        return_tmb_object = TRUE, area = 2*2)
# 
# # SD 27
# preds_cod27 <- predict(m, newdata = filter(pred_grid, sub_div == 27),
#                        return_tmb_object = TRUE, area = 2*2)
# 
# # SD 28
# preds_cod28 <- predict(m, newdata = filter(pred_grid, sub_div == 28),
#                        return_tmb_object = TRUE, area = 2*2)
# 
# # Now calculate the CPUE index (average)
# index_ave <- get_index(preds_cod_ave, bias_correct = FALSE)
# index <- get_index(preds_cod, bias_correct = FALSE)
# index24_25 <- get_index(preds_cod24_25, bias_correct = FALSE)
# index25_28 <- get_index(preds_cod25_28, bias_correct = FALSE)
# index24 <- get_index(preds_cod24, bias_correct = FALSE)
# index25 <- get_index(preds_cod25, bias_correct = FALSE)
# index26 <- get_index(preds_cod26, bias_correct = FALSE)
# index27 <- get_index(preds_cod27, bias_correct = FALSE)
# index28 <- get_index(preds_cod28, bias_correct = FALSE)
# 
# # By sub divisions
# index <- index %>% mutate(sub_div = "Total")
# index24 <- index24 %>% mutate(sub_div = "24")
# index25 <- index25 %>% mutate(sub_div = "25")
# index26 <- index26 %>% mutate(sub_div = "26")
# index27 <- index27 %>% mutate(sub_div = "27")
# index28 <- index28 %>% mutate(sub_div = "28")
# 
# div_index <- bind_rows(index, index24, index25, index26, index27, index28)
```

## Compare average in data with get index function

```{r plot indices, message=FALSE, cache=TRUE}
# # Comparing to average cpue in data
# d_sum <- d %>% 
#   ungroup() %>% 
#   group_by(year) %>%
#   summarise(mean_density = mean(density),
#             tot_density = sum(density))
# 
# index_ave %>%
#   ggplot(., aes(year, est)) +
#   geom_line() + 
#   geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4) +
#   theme(axis.text.x = element_text(angle = 30),
#         legend.position = c(0.8, 0.8)) +
#   scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) +
#   labs(x = "Year", y = expression(paste("Density [kg/", km^2, "]", sep = ""))) +
#   NULL
# 
# # E-mail method from Sean - results in the same estimated average... 
# # ... and both are comparable to the average cpue in the data
# get_average_log_density <- function(obj, level = 0.95, ...)  {
#   sdmTMB:::get_generic(obj, value_name = "link_total",
#     bias_correct = FALSE, level = level, trans = I, ...)
# }
# 
# avg <- get_average_log_density(preds_cod_ave)
# 
# d_sum <- d %>%
#   ungroup() %>%
#   group_by(year) %>%
#   summarise(mean_density = mean(density))
# 
# avg %>%
#   ggplot(., aes(year, exp(est))) +
#   geom_line() +
#   geom_ribbon(aes(ymin = exp(lwr), ymax = exp(upr)), alpha = 0.4) +
#   geom_point(data = d_sum, aes(year, mean_density)) +
#   geom_line(data = d_sum, aes(year, mean_density), linetype = 2) +
#   labs(x = "Year", y = expression(paste("Density [kg/", km^2, "]", sep = ""))) +
#   geom_point(data = index_ave, aes(year, est), color = "red", inherit.aes = FALSE) + # The get_index method
#   NULL
```

## Annual indices using `get_index_sims` method to avoid slow bias correction (not done above!)

```{r pred cod sim, cache=TRUE}
# preds_cod_sim <- predict(m, newdata = pred_grid, sims = 100)
# x <- get_index_sims(preds_cod_ave_sim, area = rep(2*2, nrow(preds_cod_ave_sim)))
# 
# ggplot(x, aes(year, est/1000, ymin = lwr/1000, ymax = upr/1000)) +
#     geom_line() +
#     geom_ribbon(alpha = 0.4)
# x_sims <- get_index_sims(preds_cod_ave_sim, return_sims = TRUE)
# ggplot(x_sims, aes(as.factor(year), log(.value))) +
#     geom_violin()

###
# Now get the total index by specifying the area of a grid cell
# Total prediction 
preds_cod_sim <- predict(m, newdata = pred_grid, sims = 100)

# Total prediction (omitting SD 24!)
preds_cod25_28_sim <- predict(m, newdata = filter(pred_grid, !sub_div == 24), sims = 100)

# SD 24-25
preds_cod24_25_sim <- predict(m, newdata = filter(pred_grid, sub_div %in% c(24, 25)), sims = 100)

# SD 24
preds_cod24_sim <- predict(m, newdata = filter(pred_grid, sub_div == 24), sims = 100)

# SD 25
preds_cod25_sim <- predict(m, newdata = filter(pred_grid, sub_div == 25), sims = 100)

# SD 26
preds_cod26_sim <- predict(m, newdata = filter(pred_grid, sub_div == 26), sims = 100)

# SD 27
preds_cod27_sim <- predict(m, newdata = filter(pred_grid, sub_div == 27), sims = 100)

# SD 28
preds_cod28_sim <- predict(m, newdata = filter(pred_grid, sub_div == 28), sims = 100)

# Now calculate the CPUE index (average)
index_sim <- get_index_sims(preds_cod_sim, area = rep(2*2, nrow(preds_cod_sim)))
index24_25_sim <- get_index_sims(preds_cod24_25_sim, area = rep(2*2, nrow(preds_cod24_25_sim)))
index25_28_sim <- get_index_sims(preds_cod25_28_sim, area = rep(2*2, nrow(preds_cod25_28_sim)))
index24_sim <- get_index_sims(preds_cod24_sim, area = rep(2*2, nrow(preds_cod24_sim)))
index25_sim <- get_index_sims(preds_cod25_sim, area = rep(2*2, nrow(preds_cod25_sim)))
index26_sim <- get_index_sims(preds_cod26_sim, area = rep(2*2, nrow(preds_cod26_sim)))
index27_sim <- get_index_sims(preds_cod27_sim, area = rep(2*2, nrow(preds_cod27_sim)))
index28_sim <- get_index_sims(preds_cod28_sim, area = rep(2*2, nrow(preds_cod28_sim)))

# Join indices
index_sim <- index_sim %>% mutate(sub_div = "Total")
index24_sim <- index24_sim %>% mutate(sub_div = "24")
index25_sim <- index25_sim %>% mutate(sub_div = "25")
index26_sim <- index26_sim %>% mutate(sub_div = "26")
index27_sim <- index27_sim %>% mutate(sub_div = "27")
index28_sim <- index28_sim %>% mutate(sub_div = "28")

div_index_sim <- bind_rows(index_sim, index24_sim, index25_sim, index26_sim, index27_sim, index28_sim)
```

## Combined plot with biomass index by sd, total and predictions on map for two years

```{r make cpue index and cpue pred on map figure, message=FALSE}
div_index_sim <- div_index_sim %>% mutate(est_t = est/1000, lwr_t = lwr/1000, upr_t = upr/1000) 

ind_plot_sd <- 
  ggplot() +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) +
  geom_line(data = filter(div_index_sim, !sub_div == "Total"), aes(year, est_t, color = sub_div)) + 
  geom_ribbon(data = filter(div_index_sim, !sub_div == "Total"), aes(year, ymin = lwr_t, ymax = upr_t, fill = sub_div), alpha = 0.2) +
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2", name = "ICES Sub division") +
  guides(color = FALSE) + 
  labs(x = "Year", y = "Tonnes", fill = "Sub Divisions") +
  theme_plot() +
  theme(legend.key.height = unit(0.2, "cm"),
        legend.key.width = unit(0.2, "cm"),
        legend.margin = margin(0, 0, 0, 0),
        legend.background = element_blank(),
        plot.margin = unit(c(0, 0.1, 0.15, 0), "cm"),
        legend.position = "bottom") +
  NULL

ind_plot_tot <- 
  ggplot() +
  geom_line(data = filter(div_index_sim, sub_div == "Total"),
            aes(year, est_t)) +
  geom_ribbon(data = filter(div_index_sim, sub_div == "Total"),
              aes(year, ymin = lwr_t, ymax = upr_t, fill = "Total"), alpha = 0.4) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) +
  scale_fill_manual(values = "grey40") + 
  labs(x = "Year", y = "Tonnes", fill = "") +
  theme_plot() +
  theme(legend.key.height = unit(0.2, "cm"),
        legend.margin = margin(0, 0, 0, 0),
        legend.background = element_blank(),
        plot.margin = unit(c(0, 0.1, 0.15, 0), "cm"),
        legend.position = "bottom") +
  NULL

cpue_map_95_17 <- plot_map_raster_labels +
  geom_raster(data = filter(predict_mcod, year %in% c("1995", "2017")), aes(x = X * 1000, y = Y * 1000, fill = exp(est))) +
  scale_fill_viridis_c() +
  facet_wrap(~ year, ncol = 2) +
  labs(fill = expression(kg/km^2)) +
  theme_plot() +
  theme(plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.text = element_text(size = 6),
        legend.position = "bottom") +
  NULL

(ind_plot_sd + ind_plot_tot) / cpue_map_95_17 + plot_annotation(tag_levels = 'A') 

ggsave("figures/density.png", width = 6.5, height = 6.5, dpi = 600)
```

## Calculate biomass weighted-overlap index with saduria and sprat

```{r biomass-weighted overlap plots, message=FALSE}
# Calculate biomass-weighted overlap of cod and saduria
predict_mcod_sad <- predict_mcod %>% 
  filter(!sub_div == 24) %>% # Filter sub division 24 where there are no saduria anyway...
  mutate(est_kg_km = exp(est)) %>% # est is response scale not link, saduria is unit g/m2
  drop_na(est_kg_km) %>% 
  drop_na(density_saduria) %>% 
  group_by(year) %>% 
  mutate(numerator = (est_kg_km / max(est_kg_km)) * (density_saduria / max(density_saduria)),
         denominator = density_saduria / max(density_saduria)) %>% 
  summarise(sum_num = sum(numerator),
            sum_den = sum(denominator),
            BWOI = sum_num / sum_den) %>% # max is here within a year)
  ungroup()

sad_plot <- ggplot(predict_mcod_sad) +
  geom_point(aes(year, BWOI), size = 1.3, color = "gray30") +
  stat_smooth(aes(year, BWOI), method = "gam", formula = y ~ s(x, k = 3),
              color = "tomato") +
  theme_plot() +
  labs(x = "Year") +
  labs(y = "Saduria overlap index") + 
  theme(plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm"),
        axis.text.x = element_text(angle = 0)) +
  NULL

sad_plot

# Calculate biomass-weighted overlap index (across year and ices rectangle)
predict_mcod_rec <- predict_mcod %>% 
  drop_na(biomass_spr) %>% 
  group_by(year) %>% 
  mutate(numerator = (est / max(est)) * (biomass_spr / max(biomass_spr)),
         denominator = (biomass_spr / max(biomass_spr))) %>% 
  summarise(sum_num = sum(numerator),
            sum_den = sum(denominator),
            BWOI = sum_num / sum_den) %>% # max is here within a year)
  ungroup() %>% 
  dplyr::select(year, BWOI) %>% 
  mutate(Scale = "ICES Rectangle")

# Calculate biomass-weighted overlap index (across year and ices sub division)
predict_mcod_sd <- predict_mcod %>% 
  drop_na(biomass_spr) %>% 
  group_by(year) %>% 
  mutate(numerator = (est / max(est)) * (biomass_spr_sd / max(biomass_spr_sd)),
         denominator = (biomass_spr_sd / max(biomass_spr_sd))) %>% 
  summarise(sum_num = sum(numerator),
            sum_den = sum(denominator),
            BWOI = sum_num / sum_den) %>% # max is here within a year)
  ungroup() %>% 
  dplyr::select(year, BWOI) %>% 
  mutate(Scale = "ICES Sub division")

overlap_sprat <- bind_rows(predict_mcod_rec, predict_mcod_sd)

pal <- brewer.pal(n = 8, name = "Dark2")[c(6,8)]

spr_plot <- ggplot(overlap_sprat, aes(year, BWOI, color = Scale, fill = Scale)) + 
  geom_point(size = 1.3) +
  scale_color_manual(values = pal) +
  scale_fill_manual(values = pal) +
  stat_smooth(method = "gam", formula = y ~ s(x, k = 3)) +
  theme_plot() +
  labs(y = "Sprat overlap index", x = "Year") + 
  theme(plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm"),
        axis.text.x = element_text(angle = 0))
  
spr_plot

# Plot bathymetry
bathy_plot <- plot_map_raster_labels +
  geom_raster(data = filter(predict_mcod, year == "1999"), aes(x = X * 1000, y = Y * 1000, fill = depth)) +
  scale_fill_distiller(palette = "Blues", direction = 1) +
  labs(fill = "Depth") +
  theme_plot() +
  theme(legend.position = "bottom",
        plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm"))
  NULL
  
# Now calculate deciles of the biomass-weighted values
pal <- c(rev(brewer.pal(n = 8, name = "Dark2")), "gray20")

wm_depth <- predict_mcod %>%
  group_by(year) %>%
  summarise("Density-weighted (5th decile, median)" = hutils::weighted_quantile(v = depth, w = exp(est), p = c(0.5)),
            "Density-weighted (1st decile)" = hutils::weighted_quantile(v = depth, w = exp(est), p = c(0.1)),
            "Density-weighted (9th decile)" = hutils::weighted_quantile(v = depth, w = exp(est), p = c(0.9))) %>% 
  pivot_longer(cols = c("Density-weighted (5th decile, median)", "Density-weighted (1st decile)", "Density-weighted (9th decile)"),
               names_to = "series", values_to = "depth") %>% 
  group_by(series) %>%  # standardize within for easy plotting
  mutate(depth_ct = depth - mean(depth)) %>% 
  ungroup()
  
plot_w_dep <- ggplot(wm_depth, aes(year, depth, color = series, group = series, fill = series)) +
  stat_smooth(method = "gam", formula = y ~ s(x, k = 4), se = FALSE, size = 1) +
  geom_point(size = 1.5, alpha = 0.8, color = "white", shape = 21) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) +
  scale_color_manual(values = pal) +
  scale_fill_manual(values = pal) +
  guides(fill = FALSE, color = guide_legend(nrow = 4)) +
  labs(y = "Depth [m]", x = "Year", color = "") +
  scale_y_reverse() + 
  theme_plot() +
  theme(legend.position = "bottom",
        plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm")) +
  NULL

# Plot oxygen in 1999
oxy_plot <- plot_map_raster_labels +
  geom_raster(data = filter(predict_mcod, year == "1999"), aes(x = X * 1000, y = Y * 1000, fill = oxy)) +
  scale_fill_viridis() +
  labs(fill = expression(paste("O" [2], " [ml/L]", sep = ""))) +
  theme_plot() +
  theme(legend.position = "bottom",
        plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm"))
  NULL

# Plot biomass-weighted oxygen
annual_oxy <- pred_grid %>%
  drop_na(oxy) %>%
  group_by(year) %>%
  summarize(median_oxy = median(oxy)) %>%
  ungroup() %>% 
  rename("oxy" = "median_oxy") %>% 
  mutate(series = "Median in environment",
         oxy_ct = oxy - mean(oxy))
  
# Weighted total
wm_oxy <- predict_mcod %>%
  group_by(year) %>%
  summarise("Density-weighted (5th decile, median)" = hutils::weighted_quantile(v = oxy, w = exp(est), p = c(0.5)),
            "Density-weighted (1st decile)" = hutils::weighted_quantile(v = oxy, w = exp(est), p = c(0.1)),
            "Density-weighted (9th decile)" = hutils::weighted_quantile(v = oxy, w = exp(est), p = c(0.9))) %>% 
  pivot_longer(cols = c("Density-weighted (5th decile, median)", "Density-weighted (1st decile)", "Density-weighted (9th decile)"),
               names_to = "series", values_to = "oxy") %>% 
  ungroup() %>% 
  group_by(series) %>% # standardize within for easy plotting
  mutate(oxy_ct = oxy - mean(oxy)) %>%
  ungroup()

oxygen_series <- bind_rows(wm_oxy, annual_oxy)

plot_w_oxy <-
ggplot(oxygen_series, aes(year, oxy, color = series, group = series, fill = series, linetype = series)) +
  stat_smooth(method = "gam", formula = y ~ s(x, k = 4), se = FALSE, size = 1) +
  geom_point(size = 1.5, alpha = 0.8, color = "white", shape = 21) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) +
  scale_linetype_manual(values = c(1,1,1,2)) +
  scale_color_manual(values = pal) +
  scale_fill_manual(values = pal) +
  guides(fill = FALSE, linetype = FALSE, color = guide_legend(nrow = 4)) +
  labs(y = expression(paste("O" [2], " [ml/L]", sep = "")), x = "Year",
       color = "") +
  theme_plot() +
  theme(legend.position = "bottom",
        plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm")) +
  NULL

(bathy_plot | plot_w_dep) / (oxy_plot | plot_w_oxy) / (sad_plot | spr_plot) +
  plot_annotation(tag_levels = 'A')

ggsave("figures/density_weighted_dep_oxy_sad_spr.png", width = 6.5, height = 8.5, dpi = 600)
```

### Plot biomass-weighted temperature

```{r biomass-weighted temperature, message=FALSE}
# Plot temperature in 1999
temp_plot <- plot_map_raster +
  geom_raster(data = filter(predict_mcod, year == "1999"), aes(x = X * 1000, y = Y * 1000, fill = temp)) +
  scale_fill_viridis(option = "inferno", direction = -1) +
  labs(fill = "Temperature [°C]") +
  theme_plot() +
  theme(legend.position = "bottom",
        plot.margin = unit(c(0, 0.1, 0, 0.2), "cm"))
  NULL

annual_temp <- pred_grid %>%
  drop_na(temp) %>%
  group_by(year) %>%
  summarize(median_temp = median(temp)) %>%
  ungroup() %>%
  rename("temp" = "median_temp") %>%
  mutate(series = "Median in environment",
         temp_ct = temp - mean(temp))

# Weighted total
wm_temp <- predict_mcod %>%
  group_by(year) %>%
  summarise("Density-weighted (5th decile, median)" = hutils::weighted_quantile(v = depth, w = exp(est), p = c(0.5)),
            "Density-weighted (1st decile)" = hutils::weighted_quantile(v = depth, w = exp(est), p = c(0.1)),
            "Density-weighted (9th decile)" = hutils::weighted_quantile(v = depth, w = exp(est), p = c(0.9))) %>%
  pivot_longer(cols = c("Density-weighted (5th decile, median)", "Density-weighted (1st decile)", "Density-weighted (9th decile)"),
               names_to = "series", values_to = "temp") %>%
  ungroup() %>%
  group_by(series) %>% # standardize within for easy plotting
  mutate(temp_ct = temp - mean(temp)) %>%
  ungroup()

temp_series <- bind_rows(wm_temp, annual_temp)

plot_w_temp <-
  ggplot(temp_series, aes(year, temp, color = series, group = series, fill = series, linetype = series)) +
  stat_smooth(method = "gam", formula = y ~ s(x, k = 4), se = FALSE, size = 1) +
  geom_point(size = 1.5, alpha = 0.8, color = "white", shape = 21) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) +
  scale_linetype_manual(values = c(1,1,1,2)) +
  scale_color_manual(values = pal) +
  scale_fill_manual(values = pal) +
  guides(fill = FALSE, linetype = FALSE, color = guide_legend(nrow = 4)) +
  labs(y = "Temperature [°C]", x = "Year",
       color = "") +
  theme_plot() +
  theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
  NULL
temp_plot + plot_w_temp +
  plot_annotation(tag_levels = 'A') + plot_layout(ncol = 2)

ggsave("figures/supp/density/weighted_temp.png", width = 6.5, height = 8.5, dpi = 600)
```

## Marginal effect of oxygen

```{r marginal effects oxygen, message=FALSE, cache=TRUE}
# Prepare prediction data frame
d2 <- d %>% drop_na(oxy)
nd_oxy <- data.frame(oxy = seq(min(d2$oxy), max(d2$oxy), length.out = 100))

nd_oxy <- nd_oxy %>%
  mutate(year = 2003L,
         depth_sc = 0,
         oxy_sc = (oxy - mean(oxy))/sd(oxy),
         temp_sc = 0)

# Predict
p_margin_oxy <- predict(m, newdata = nd_oxy, se_fit = TRUE, re_form = NA)

mar_oxy <- ggplot(p_margin_oxy, aes(oxy, exp(est),
  ymin = exp(est) - 1.96 * exp(est_se), ymax = exp(est) + 1.96 * exp(est_se))) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  coord_cartesian(ylim = c(30, 220)) +
  theme(aspect.ratio = 1) +
  labs(x = expression(Oxygen[haul]))
```

## Marginal effect of depth

```{r marginal effects depth, message=FALSE, cache=TRUE}
# Prepare prediction data frame
nd_dep <- data.frame(depth = seq(min(d2$depth), max(d2$depth), length.out = 100))

nd_dep <- nd_dep %>%
  mutate(year = 2003L,
         depth_sc = (depth - mean(depth))/sd(depth),
         oxy_sc = 0,
         temp_sc = 0)

# Predict
p_margin_dep <- predict(m, newdata = nd_dep, se_fit = TRUE, re_form = NA)

mar_depth <- ggplot(p_margin_dep, aes(depth, exp(est),
  ymin = exp(est) - 1.96 * exp(est_se), ymax = exp(est) + 1.96 * exp(est_se))) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  coord_cartesian(ylim = c(30, 220)) +
  theme(aspect.ratio = 1) +
  labs(x = expression(Depth[haul]))
```

## Marginal effect of temperature

```{r marginal effects temperature, message=FALSE, cache=TRUE}
# Prepare prediction data frame
nd_temp <- data.frame(temp = seq(min(d$temp), max(d$temp), length.out = 100))

nd_temp <- nd_temp %>%
  mutate(year = 2003L,
         depth_sc = 0,
         oxy_sc = 0,
         temp_sc = (temp - mean(temp))/sd(temp))

# Predict
p_margin_temp <- predict(m, newdata = nd_temp, se_fit = TRUE, re_form = NA)

mar_temp <- ggplot(p_margin_temp, aes(temp, exp(est),
  ymin = exp(est) - 1.96 * exp(est_se), ymax = exp(est) + 1.96 * exp(est_se))) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  coord_cartesian(ylim = c(30, 220)) +
  theme(aspect.ratio = 1) +
  labs(x = expression(Temp[haul]))
```

### Plot together

```{r}
mar_temp + mar_depth + mar_oxy +
  plot_annotation(tag_levels = 'A') 

ggsave("figures/supp/density/marginal_effects.png", width = 6.5, height = 6.5, dpi = 600)
```

```{r}
knitr::knit_exit()
```
