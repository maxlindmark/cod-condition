---
title: "Exploring sdmTMB for cod condition"
author: "Max Lindmark"
date: "9/18/2020"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

```{r setup, include = FALSE, cache=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.asp = 0.618
)
```


## Background

The body condition and growth of Eastern Baltic cod has declined steadily since the regime shift in the early 1990's to a degree that it now can be viewed as collapsed. Several hypotheses have been put forward, including changes in overlap with pelagic prey (e.g. Gårdmark et al, 2015), reduced oxygen levels (e.g. Casini et al, 2016), increased competition for benthic food sources with flounder (Orio et al, 2019) as well as increased intraspecific competition and growth bottlenecks within the population (Svedäng & Hornborg, 2014).  


## Methods

In this script I will fit spatiotemporal models of allometric weight-length relationships ($w=\alpha l^ \beta$ -> $log(w) = \alpha + \beta log(l) + \beta_x x$) using [sdmTMB](https://github.com/pbs-assess/sdmTMB). I aim here to first find an appropriate model structure for evaluating how $\alpha$ (log condition factor), has changed over space and time. Next I aim to evaluate the effects of additional covariates at the haul-level ($\beta_x x$) for the predicted weight given a length.

The covariates I currently consider are:

- Density of cod. CPUE available for each haul (added in data)
- Density of flounder. CPUE available for each haul (added in data)
- Oxygen concentration. Possible to link data to nearest haul *(not yet added)*
- Sprat CPUE. *(not yet added)*
- Herring CPUE. *(not yet added)*
- maybe: temperature as a base-covariate through it's effect on growth, metabolism, digestion etc.

(Re pelagics: Semi coarse predictions exist (by ICES rectangle). I can either do a join operation to get the estimated CPUE by rectangle linked to all hauls in that rectangle, or attempt to fit a new model and predict CPUE for the locations where I have haul conditions. Going for the former I think...).

The project currently lives [here](https://github.com/maxlindmark/cod_condition). Below follows a walkthrough of the first attempts to model this.

```{r packages, message=FALSE, warning=TRUE}
library(tidyverse)
library(tidylog)
library(viridis)
library(sdmTMB)
library(marmap)
library(curl)
```

Now read data

```{r read data}
#d <- read.csv("data/mdat_cond.csv") 
# SA: or readr::read_csv("https://raw.githubusercontent.com/maxlindmark/cod_condition/master/data/mdat_cond.csv")
d <- read.csv(
  curl(
    "https://raw.githubusercontent.com/maxlindmark/cod_condition/master/data/mdat_cond.csv"
    ))

# Calculate some variables in data
d <- d %>%
  dplyr::select(-X) %>% 
  rename("Y" = "lat", "X" = "lon") %>% 
  mutate(ln_weight_g = log(weight_g),
         ln_length_cm = log(length_cm),
         Fulton_K = weight_g/(0.01*length_cm^3)) %>% # Just an approximation for now
  dplyr::select(year, Y, X, sex, length_cm, weight_g, Quarter, CPUE_cod, CPUE_fle,
                ln_length_cm, ln_weight_g, Fulton_K)

```

I will next standardize the covariates to have a mean of 0 and variance of 1 to facilitate comparison between different ones, and read in the prediction grid.


```{r read and process data}
d <- d %>% 
  mutate(CPUE_cod_st = CPUE_cod,
         CPUE_fle_st = CPUE_fle) %>% 
  mutate_at(c("CPUE_cod_st", "CPUE_fle_st"), ~(scale(.) %>% as.vector))

pred_grid <-
  read.csv(curl(
    "https://raw.githubusercontent.com/maxlindmark/cod_condition/master/data/pred_grid.csv"
    ))

# SA: You likely want to work in UTMs so distance is constant with space
pred_grid <- pred_grid %>%
  dplyr::select(-X.1) %>% 
  mutate(ln_length_cm = log(1), # For now we'll predict changes in the intercept (condition factor)
         X = round(X, digits = 4), # I get a strange memory issues when plotting but this solves it
         Y = round(Y, digits = 4)) %>% 
  filter(year %in% c(unique(d$year)))
```

We can now plot the Fulton K condition factor to get a glimpse of what we might expect (but finally our estimates are closer to Le Cren's condition index).

```{r, fig.height=14}
# Plot "Fulton K" in space and time 
d %>%
  ggplot(., aes(X, Y, color = Fulton_K)) + 
  geom_point(size = 1.2, alpha = 0.8) + 
  facet_wrap(~ year, ncol = 5) +
  scale_color_gradient2(midpoint = mean(d$Fulton_K)) +
  theme_classic(base_size = 8) + 
  NULL
```

Ok there's a clear temporal development in condition and the spatial coverage of data varies by year (less data initially).

Next we fit spatial/spatiotemporal models to account for this. Given that we do not have samples in all spatial locations for all years, and we believe that there are "hotpots" of body condition, we model a temporal correlation for the spatiotemporal variation (Thorson, 2019), specifically, this is done by estimating the spatiotemporal fields as an AR1 process. Hence, we set ar1_fields = TRUE.

I will start by setting up the SPDE mesh with 75 knots and alter I will fit and compare models with more knots. In the first step I will compare a Gaussian with a student t model to see which distribution seems more appropriate.


```{r fit spatiotemporal glmm, results='hide', message=FALSE}
# SA: good for now; could increase knots eventually:
spde <- make_spde(d$X, d$Y, n_knots = 75)
plot_spde(spde)

# Compare Gaussian and student t models with a spatiotemporal AR1 process
m0 <- sdmTMB(formula = ln_weight_g ~ ln_length_cm, data = d, time = "year", spde = spde,
             family = gaussian(link = "identity"), ar1_fields = TRUE,
             include_spatial = TRUE,  spatial_trend = FALSE, spatial_only = FALSE,
             silent = FALSE) 

# SA: note that the degrees of freedom on the Student-t are fixed out 3 currently; we can tweak that so you could specify it if you want.
# SA: working in log space and Student-t might be fine here, though it's possible that something like Gamma(link = "log") or lognormal might capture the mean-variance relationship better and not require the transformation.
m1 <- sdmTMB(formula = ln_weight_g ~ ln_length_cm, data = d, time = "year", spde = spde,
             family = student(link = "identity"), ar1_fields = TRUE,
             include_spatial = TRUE, spatial_trend = FALSE, spatial_only = FALSE,
             silent = FALSE) 

# Inspect fitted models
print(m0)
print(m1)

# Look at the residuals:
df <- d

df$residuals_m0 <- residuals(m0)
df$residuals_m1 <- residuals(m1)

qqnorm(df$residuals_m0); abline(a = 0, b = 1)
```

Gaussian looks bad.

```{r}
qqnorm(df$residuals_m1); abline(a = 0, b = 1)
```

Student looks a lot better but could perhaps be improved further. Check the residuals for the student t model on a map.


```{r}
ggplot(df, aes(X, Y, colour = residuals_m1)) +
  geom_point(size = 1) +
  facet_wrap(~year, ncol = 5) +
  scale_color_gradient2() +
  theme_classic() +
  coord_fixed()
```

Maybe some clustering remains...

However, moving on we can also look at the AR1 parameter to ensure it is warranted.

```{r}
# SA: Note that this is in -Inf to Inf space, although you are probably aware of that; `2 * plogis(ar_phi) - 1` will transform it
# SA: also note that you can use (1) the already calculated sdreport and (2) the as.list S3 method for a handy named list... no more row.names()!:
example_est <- as.list(m1$sd_report, "Estimate")
example_se <- as.list(m1$sd_report, "Std. Error")
2 * plogis(example_est$ar1_phi + c(-2, 2) * example_se$ar1_phi) - 1

sd1 <- as.data.frame(summary(TMB::sdreport(m1$tmb_obj)))
sd1$Estimate[row.names(sd1) == "ar1_phi"]
sd1$Estimate[row.names(sd1) == "ar1_phi"] +
  c(-2, 2) * sd1$`Std. Error`[row.names(sd1) == "ar1_phi"]
```

Strong support for it, will not run model without AR1 process in the spatiotemporal field for now.

Hence, I will proceed with this model, makes some predictions and compare it to a model with covariates.

So, now we can predict and plot estimates using all fixed and random effects on pre-made grid. This grid is made by doing an expand grid over survey ranges, then filtering out areas that are actually in the ocean using ICES shapefiles. Lastly some areas are too deep for sampling (-135 m). I've added a depth column so that I can make those predictions NA so it's clear they are different from e.g. land and islands (maybe unnessecary but it makes them grey, i.e. different from land. 

```{r}
p <- predict(m1, newdata = pred_grid)

# Replace too-deep predictions with NA
p <- p %>% mutate(est2 = ifelse(depth < -130, NA, est),
                  eps_st2 = ifelse(depth < -130, NA, epsilon_st),
                  omega_s2 = ifelse(depth < -130, NA, omega_s))
```

Plot the predicted condition with fixed and random effects:

```{r}
ggplot(p, aes(X, Y, fill = est2)) +
  geom_raster() +
  facet_wrap(~year, ncol = 5) +
  scale_fill_viridis(option = "magma", 
                     name = "log(condition factor)") + 
  theme_bw(base_size = 8) +
  coord_cartesian(expand = 0) + 
  ggtitle("Prediction (random + fixed)")
```

Plot the spatiotemporal random effects:

SA: Note that these are the spatial (omega) + spatiotemporal (epsilon) effects. If you just want the spatiotemporal ones, then you want `p$epsilon_st`. I have done that above.
SA: You likely want a diverging colour scheme for these since they will be centered on 0. I have done that.
SA: typically each time slice would be centered on zero, however you have a moderately large AR1 phi parameter, which is letting it wander off a bit
SA: an alternative might be the spatial_trend (since what you have look roughly linear) likely instead of the AR1 form, I would be interested to hear if that works well. If everything is generally decreasing, you could also try just having a fixed effect for year, which might be simplest of all and useful for inference... or let the intercept be a random walk through time:
`formula = ln_weight_g ~ 0 + ln_length_cm, time_varying = ~ 1`
SA: hopefully that's right, I haven't tried it here
SA: All depends on what the end goal is for inference and what is most useful.

```{r}
ggplot(p, aes(X, Y, fill = eps_st2)) +
  geom_raster() +
  facet_wrap(~year, ncol = 5) +
  # scale_fill_viridis(option = "magma", 
  scale_fill_gradient2(
                     name = "log(condition factor)") + 
  theme_bw(base_size = 8) +
  coord_cartesian(expand = 0) + 
  ggtitle("Spatiotemporal random effects")
```

Plot the spatial random effects:

```{r}
ggplot(filter(p, year == 2000), aes(X, Y, fill = omega_s2)) +
  geom_raster() +
  # scale_fill_viridis(option = "magma", 
  scale_fill_gradient2(
                     name = "log(condition factor)") + 
  theme_bw() +
  coord_cartesian(expand = 0) + 
  geom_point(data = d, aes(X, Y), color = "green", inherit.aes = FALSE, size = 0.2) +
  ggtitle("Spatial random effects + data")
```

SA: there are also the `p$est_non_rf` for just the fixed effects (and time-varying effects) if you want to look at that

Predictions with fixed and random effects and the spatiotemporal random effect are quite similar. I guess this is because I don't have any other strong covariates yet (and the length-variable is set to 0 for this prediction). All random effects (and predictions) also seem to largely follow depth. Not really sure how to interpret that. At the deeper areas there is less oxygen and less benthic food so in theory it can make sense).

```{r}
baltic_sea <- getNOAA.bathy(lon1 = min(d$X), lon2 = max(d$X),
                            lat1 = min(d$Y), lat2 = max(d$Y), resolution = 15)

autoplot(baltic_sea, geom = c("r", "c")) +
  scale_fill_gradient2(low = "darkblue", high = "gray", midpoint = 0)
```

Now we want to refit the same model with the additional fixed effects outlined above.

```{r spatiotemporal glmm with covariates}
# Fit model with cod cpue as covariate
mcod <- sdmTMB(formula = ln_weight_g ~ ln_length_cm + CPUE_cod_st, data = d, time = "year",
               spde = spde, family = student(link = "identity"), 
               ar1_fields = TRUE,
               include_spatial = TRUE, 
               spatial_trend = FALSE, 
               spatial_only = FALSE,
               silent = FALSE)

# Run extra optimization steps to help convergence:
mcod2 <- run_extra_optimization(mcod, nlminb_loops = 1, newton_steps = 1)

# SA: interesting; you might try more knots (or sometimes fewer) or even a different seed on the make_spde function.
## ---------- Actually this did not improve convergence this time!

#... And with flounder 
mfle <- sdmTMB(formula = ln_weight_g ~ ln_length_cm + CPUE_fle_st, data = d, time = "year",
               spde = spde, family = student(link = "identity"), 
               ar1_fields = TRUE,
               include_spatial = TRUE, 
               spatial_trend = FALSE, 
               spatial_only = FALSE,
               silent = FALSE) # sorry if this ruined the .Rmd output!

# Run extra optimization steps to help convergence:
mfle2 <- run_extra_optimization(mfle, nlminb_loops = 1, newton_steps = 1)
max(mfle2$gradients)

# Check the models
print(mcod2)
print(mfle2)

# Look at the new parameter (cod)
# SA: use mcod2$sdreport !
sdmcod <- as.data.frame(summary(mcod2$sd_report))

sdmcod$Estimate[row.names(sdmcod) == "b_j.2"] # The second term, aka cod

sdmcod$Estimate[row.names(sdmcod) == "b_j.2"] +
  c(-2, 2) * sdmcod$`Std. Error`[row.names(sdmcod) == "b_j.2"]

#... And the same for flounder
sdmfle <- as.data.frame(summary(mfle2$sd_report))

sdmfle$Estimate[row.names(sdmfle) == "b_j.2"] # The second term, aka flounder

sdmfle$Estimate[row.names(sdmfle) == "b_j.2"] +
  c(-2, 2) * sdmfle$`Std. Error`[row.names(sdmfle) == "b_j.2"]

# Compare the models with AIC (unsure actually if this is correct for a sdmTMB model...)
# SA: as long as only the fixed effects change and reml = FALSE, then yes
# SA: if random effects change and reml = TRUE, then yes
# SA: all conditional on whether AIC is a good thing to use for this type of model... but people do
aic_m1 <- extractAIC(m1)
aic_mcod <- extractAIC(mcod2)
aic_mfle <- extractAIC(mfle2)

aic_m1
aic_mcod
aic_mfle
```

Despite some convergence problems I will proceed just as an example. The model with flounder has a smaller AIC, even though the 95% confidence interval for it's coefficient crosses 0 (unlike the coefficient for cod).

Now let's look more closely at the our estimates. If I understand Thorson (2015) correctly:

*"This implies that $\gamma X$ (the covariate times its coefficient) has a standard deviation of $\gamma$ such that coefficients can be interpreted via comparison with the standard deviation of spatial, temporal and spatiotemporal variation, as well as that of residual variation."*

I can now compare the coefficient of flounder with the standard deviation of the spatial and spatiotemporal effects, i.e. $\sigma_E$ and $\sigma_A$ in Thorson (2015) (Eqns. 6b-7). These terms are the square roots of the marginal variances of the random fields, i.e. $\sigma_E^2$ and $\sigma_A^2$.

In sdmTMB I think $\sigma_E$ and $\sigma_A$ above correspond to Spatiotemporal SD (sigma_E) and Spatial SD (sigma_O) seen in "print(model)". I think the non-rounded values can be extracted from:

```{r}
mfle2$sd_report$value
# SA: correct, or as a named list (note the last argument):
est <- as.list(mfle2$sd_report, "Estimate", report = TRUE)
se <- as.list(mfle2$sd_report, "Std. Error", report = TRUE)
est$sigma_O
se$sigma_O
```

These standard deviations can now be compared with the coefficients of the flounder model:

```{r}
sdmfle$Estimate[row.names(sdmfle) == "b_j.2"] # The second term, aka flounder
```

I interpret this as that the flounder coefficient is small relative to other sources of temporally constant variation across space (omega) and factors varying in space from year to year (epsilon). Further, I don't think inclusion of the flounder covariate leads to less variation explained by the spatial and spatiotemporal effects. Compare those standard deviations with the model without covariates:

```{r}
m1$sd_report$value
```

For the sake of comparison, I can also produce a map to look at the differences there.

```{r}
# Add in a fixed covariate here
pred_grid_fle <- pred_grid
pred_grid_fle$CPUE_fle_st <- 0 # Mean since standardized

pfle <- predict(mfle2, newdata = pred_grid_fle)

# Replace too-deep predictions with NA
pfle <- pfle %>% mutate(est2 = ifelse(depth < -130, NA, est))

ggplot(pfle, aes(X, Y, fill = est2)) +
  geom_raster() +
  facet_wrap(~year, ncol = 5) +
  scale_fill_viridis(option = "magma", 
                     name = "log(condition factor)") + 
  theme_bw(base_size = 8) +
  coord_cartesian(expand = 0) + 
  ggtitle("Prediction (random + fixed) with covariates")
```

## To do

- The spatial_trend argument is ignored for now [see e-mail], is my interpretation correct?

SA: it is a random field that represents a slope over the time variable; yes it is confusingly internally still called omega_s_slope or something similar. I should fix that. If TRUE, omega_s can be thought of as an intercept and omega_s_slope (zeta_s) the slope. We have a paper in review on it I could share if you want. Sorry it's badly documented... although I think there is a vignette on it.

- Do I extract the standard deviations for the spatial and spatiotemporal trends correctly, and interpret then correctly in relation to covariates?

SA: extracted correctly, yes, although see my suggested list version
SA: as for that Thorson 2015 paragraph, hmm, perhaps yes, although I hadn't thought of it that way before. I've more commonly seen assessment of covariates via the magnitude (ecological relavance), confidence interval, and/or AIC, but yes, that could be a useful scale comparison. That assumes you have scaled your predictor to have variance = 1, which might make less sense if it's a log variable.


## References

Anderson, S.C., Keppel, E.A., Edwards, A.M. 2019. A reproducible data synopsis for over 100 species of British Columbia groundfsh. DFO Can. Sci. Advis. Sec. Res. Doc. 2019/041. vii + 321 p.

Casini, M., Käll, F., Hansson, M., Plikshs, M., Baranova, T., Karlsson, O., Lundström, K., Neuenfeldt, S., Gårdmark, A. and Hjelm, J., 2016. Hypoxic areas, density-dependence and food limitation drive the body condition of a heavily exploited marine fish predator. Royal Society open science, 3(10), p.160416.

Gårdmark, A., Casini, M., Huss, M., van Leeuwen, A., Hjelm, J., Persson, L. and de Roos, A.M., 2015. Regime shifts in exploited marine food webs: detecting mechanisms underlying alternative stable states using size-structured community dynamics theory. Philosophical Transactions of the Royal Society B: Biological Sciences, 370(1659), p.20130262.

Orio, A., Bergström, U., Florin, A.B., Lehmann, A., Šics, I. and Casini, M., 2019. Spatial contraction of demersal fish populations in a large marine ecosystem. Journal of Biogeography, 46(3), pp.633-645.

Svedäng, H. and Hornborg, S., 2014. Selective fishing induces density-dependent growth. Nature communications, 5(1), pp.1-6.

Thorson, J.T., 2015. Spatio-temporal variation in fish condition is not consistently explained by density, temperature, or season for California Current groundfishes. *Marine Ecology Progress Series*, 526, pp.101-112.


